/* The following code was generated by JFlex 1.4 on 27.06.04 15:31 */
package org.dotplot.tokenizer.scanner;

import org.dotplot.tokenizer.EOLToken;
import org.dotplot.tokenizer.KeyWordToken;
import org.dotplot.tokenizer.Token;
import org.dotplot.tokenizer.TokenType;

/**
 * This class is a scanner generated by
 * <a href="http://www.jflex.de/">JFlex</a> 1.4
 * on 27.06.04 15:31 from the specification file
 * <tt>C:/Programme/eclipse/workspace/org.dotplot/src/org/dotplot/tokenizer/scanner/flexfiles/CScanner.flex</tt>.
 */
public class CScanner extends BaseScanner
{
   /**
    * This character denotes the end of file
    */
   public static final int YYEOF = -1;

   /**
    * initial size of the lookahead buffer
    */
   private static final int ZZ_BUFFERSIZE = 16384;

   /**
    * lexical states
    */
   public static final int LINE_COMMENT = 2;
   public static final int YYINITIAL = 0;
   public static final int COMMENT = 1;

   /**
    * Translates characters to character classes
    */
   private static final String ZZ_CMAP_PACKED = "\1\2\7\0\1\2\1\3\1\1\2\4\1\5\22\0\1\3\1\50"
         + "\1\10\3\0\1\51\1\0\1\54\1\55\1\7\1\43\1\45\1\44"
         + "\1\62\1\6\1\65\11\67\1\63\1\41\1\47\1\42\1\46\1\64"
         + "\1\0\32\66\1\56\1\61\1\57\1\0\1\66\1\0\1\11\1\15"
         + "\1\21\1\26\1\17\1\27\1\33\1\23\1\25\1\66\1\20\1\30"
         + "\1\31\1\24\1\14\1\37\1\66\1\16\1\22\1\13\1\12\1\40"
         + "\1\35\1\32\1\36\1\34\1\52\1\60\1\53\7\0\1\4\u1fa2\0"
         + "\2\4\udfd6\0";

   /**
    * Translates characters to character classes
    */
   private static final char[] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

   /**
    * Translates DFA states to action switch labels.
    */
   private static final int[] ZZ_ACTION = zzUnpackAction();

   private static final String ZZ_ACTION_PACKED_0 = "\3\0\1\1\1\2\1\3\1\2\1\4\1\5\1\6"
         + "\20\7\1\10\1\11\1\12\1\13\1\14\1\15\1\16"
         + "\1\17\1\20\1\21\1\22\1\23\1\24\1\25\1\26"
         + "\1\27\1\30\1\31\1\32\1\33\1\34\1\1\1\3"
         + "\1\2\2\1\2\35\1\36\1\37\1\0\20\7\1\40"
         + "\1\41\7\7\1\42\1\43\1\44\1\45\1\46\1\1"
         + "\23\7\1\47\2\7\1\50\6\7\1\51\6\7\1\52"
         + "\1\53\1\7\1\54\2\7\1\55\11\7\1\56\1\57"
         + "\1\7\1\60\2\7\1\61\1\7\1\62\4\7\1\63"
         + "\2\7\1\64\5\7\1\65\1\66\3\7\1\67\1\7"
         + "\1\70\1\7\1\71\1\72\1\73\1\74\1\75\1\76"
         + "\3\7\1\77\2\7\1\100\1\7\1\101\1\102\1\103"
         + "\1\104";

   private static int[] zzUnpackAction()
   {
      int[] result = new int[189];
      int offset = 0;
      offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
      return result;
   }

   private static int zzUnpackAction(String packed, int offset, int[] result)
   {
      int i = 0; /* index in packed string  */
      int j = offset; /* index in unpacked array */
      int l = packed.length();
      while (i < l)
      {
         int count = packed.charAt(i++);
         int value = packed.charAt(i++);
         do
         {
            result[j++] = value;
         }
         while (--count > 0);
      }
      return j;
   }

   /**
    * Translates a state to a row index in the transition table
    */
   private static final int[] ZZ_ROWMAP = zzUnpackRowMap();

   private static final String ZZ_ROWMAP_PACKED_0 = "\0\0\0\70\0\160\0\250\0\250\0\340\0\u0118\0\u0150"
         + "\0\250\0\u0188\0\u01c0\0\u01f8\0\u0230\0\u0268\0\u02a0\0\u02d8"
         + "\0\u0310\0\u0348\0\u0380\0\u03b8\0\u03f0\0\u0428\0\u0460\0\u0498"
         + "\0\u04d0\0\u0508\0\250\0\u0540\0\250\0\250\0\250\0\u0578"
         + "\0\u05b0\0\250\0\250\0\250\0\250\0\250\0\250\0\250"
         + "\0\250\0\250\0\250\0\250\0\250\0\250\0\u05e8\0\u0620"
         + "\0\u0658\0\u0620\0\u0690\0\u06c8\0\250\0\u0700\0\250\0\250"
         + "\0\u0738\0\u0770\0\u07a8\0\u07e0\0\u0818\0\u0850\0\u0888\0\u08c0"
         + "\0\u08f8\0\u0930\0\u0968\0\u09a0\0\u09d8\0\u0a10\0\u0a48\0\u0a80"
         + "\0\u0ab8\0\u0268\0\u0af0\0\u0b28\0\u0b60\0\u0b98\0\u0bd0\0\u0c08"
         + "\0\u0c40\0\u0c78\0\250\0\250\0\250\0\u0620\0\u0620\0\u0738"
         + "\0\u0cb0\0\u0ce8\0\u0d20\0\u0d58\0\u0d90\0\u0dc8\0\u0e00\0\u0e38"
         + "\0\u0e70\0\u0ea8\0\u0ee0\0\u0f18\0\u0f50\0\u0f88\0\u0fc0\0\u0ff8"
         + "\0\u1030\0\u1068\0\u10a0\0\u0268\0\u10d8\0\u1110\0\u0268\0\u1148"
         + "\0\u1180\0\u11b8\0\u11f0\0\u1228\0\u1260\0\u0268\0\u1298\0\u12d0"
         + "\0\u1308\0\u1340\0\u1378\0\u13b0\0\u0268\0\u0268\0\u13e8\0\u0268"
         + "\0\u1420\0\u1458\0\u0268\0\u1490\0\u14c8\0\u1500\0\u1538\0\u1570"
         + "\0\u15a8\0\u15e0\0\u1618\0\u1650\0\u0268\0\u0268\0\u1688\0\u0268"
         + "\0\u16c0\0\u16f8\0\u0268\0\u1730\0\u0268\0\u1768\0\u17a0\0\u17d8"
         + "\0\u1810\0\u0268\0\u1848\0\u1880\0\u0268\0\u18b8\0\u18f0\0\u1928"
         + "\0\u1960\0\u1998\0\u0268\0\u0268\0\u19d0\0\u1a08\0\u1a40\0\u0268"
         + "\0\u1a78\0\u0268\0\u1ab0\0\u0268\0\u0268\0\u0268\0\u0268\0\u0268"
         + "\0\u0268\0\u1ae8\0\u1b20\0\u1b58\0\u0268\0\u1b90\0\u1bc8\0\u0268"
         + "\0\u1c00\0\u0268\0\u0268\0\u0268\0\u0268";

   private static int[] zzUnpackRowMap()
   {
      int[] result = new int[189];
      int offset = 0;
      offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
      return result;
   }

   private static int zzUnpackRowMap(String packed, int offset, int[] result)
   {
      int i = 0; /* index in packed string  */
      int j = offset; /* index in unpacked array */
      int l = packed.length();
      while (i < l)
      {
         int high = packed.charAt(i++) << 16;
         result[j++] = high | packed.charAt(i++);
      }
      return j;
   }

   /**
    * The transition table of the DFA
    */
   private static final int[] ZZ_TRANS = zzUnpackTrans();

   private static final String ZZ_TRANS_PACKED_0 = "\1\4\1\5\2\6\1\5\1\7\1\10\1\11\1\12"
         + "\1\13\1\14\1\15\1\16\1\17\1\20\1\21\1\16"
         + "\1\22\1\23\2\16\1\24\1\25\1\26\1\27\2\16"
         + "\1\30\1\16\1\31\2\16\1\32\1\33\1\34\1\35"
         + "\1\36\1\37\1\40\1\41\1\42\1\43\1\44\1\45"
         + "\1\46\1\47\1\50\1\51\1\52\1\53\1\54\1\55"
         + "\1\56\1\57\1\16\1\57\1\60\1\5\1\61\1\6"
         + "\1\62\1\7\1\63\1\64\61\60\1\65\1\61\1\6"
         + "\1\60\1\66\62\60\72\0\2\6\65\0\1\5\74\0"
         + "\1\67\1\70\60\0\1\71\1\0\66\71\11\0\1\16"
         + "\1\72\26\16\25\0\2\16\11\0\13\16\1\73\14\16"
         + "\25\0\2\16\11\0\25\16\1\74\2\16\25\0\2\16"
         + "\11\0\30\16\25\0\2\16\11\0\5\16\1\75\22\16"
         + "\25\0\2\16\11\0\6\16\1\76\21\16\25\0\2\16"
         + "\11\0\13\16\1\77\3\16\1\100\1\16\1\101\6\16"
         + "\25\0\2\16\11\0\1\102\2\16\1\103\6\16\1\104"
         + "\15\16\25\0\2\16\11\0\2\16\1\105\7\16\1\106"
         + "\1\16\1\107\7\16\1\110\3\16\25\0\2\16\11\0"
         + "\13\16\1\111\2\16\1\112\11\16\25\0\2\16\11\0"
         + "\3\16\1\113\2\16\1\114\21\16\25\0\2\16\11\0"
         + "\3\16\1\115\13\16\1\116\10\16\25\0\2\16\11\0"
         + "\3\16\1\117\24\16\25\0\2\16\11\0\3\16\1\120"
         + "\24\16\25\0\2\16\11\0\12\16\1\121\15\16\25\0"
         + "\2\16\11\0\3\16\1\122\24\16\25\0\2\16\42\0"
         + "\1\123\67\0\1\124\67\0\1\125\112\0\1\57\1\0"
         + "\1\57\1\60\1\0\1\60\1\0\1\60\1\0\63\60"
         + "\1\0\1\61\1\6\1\60\1\0\63\60\1\0\1\60"
         + "\1\0\1\60\1\0\1\60\1\126\61\60\1\0\1\60"
         + "\1\0\1\60\1\0\1\127\61\60\1\0\1\65\66\0"
         + "\1\71\1\0\6\71\1\130\57\71\11\0\2\16\1\131"
         + "\25\16\25\0\2\16\11\0\11\16\1\132\2\16\1\133"
         + "\13\16\25\0\2\16\11\0\26\16\1\134\1\16\25\0"
         + "\2\16\11\0\6\16\1\135\21\16\25\0\2\16\11\0"
         + "\2\16\1\136\17\16\1\137\5\16\25\0\2\16\11\0"
         + "\1\16\1\140\26\16\25\0\2\16\11\0\11\16\1\141"
         + "\16\16\25\0\2\16\11\0\2\16\1\142\25\16\25\0"
         + "\2\16\11\0\11\16\1\143\16\16\25\0\2\16\11\0"
         + "\13\16\1\144\14\16\25\0\2\16\11\0\1\145\27\16"
         + "\25\0\2\16\11\0\1\146\4\16\1\147\22\16\25\0"
         + "\2\16\11\0\3\16\1\150\24\16\25\0\2\16\11\0"
         + "\22\16\1\151\1\152\4\16\25\0\2\16\11\0\14\16"
         + "\1\153\13\16\25\0\2\16\11\0\2\16\1\154\25\16"
         + "\25\0\2\16\11\0\1\16\1\155\26\16\25\0\2\16"
         + "\11\0\16\16\1\156\11\16\25\0\2\16\11\0\5\16"
         + "\1\157\22\16\25\0\2\16\11\0\3\16\1\160\24\16"
         + "\25\0\2\16\11\0\13\16\1\161\14\16\25\0\2\16"
         + "\11\0\2\16\1\162\25\16\25\0\2\16\11\0\14\16"
         + "\1\163\13\16\25\0\2\16\11\0\14\16\1\164\2\16"
         + "\1\165\10\16\25\0\2\16\11\0\3\16\1\166\24\16"
         + "\25\0\2\16\11\0\14\16\1\167\13\16\25\0\2\16"
         + "\11\0\3\16\1\170\24\16\25\0\2\16\11\0\6\16"
         + "\1\171\21\16\25\0\2\16\11\0\1\172\27\16\25\0"
         + "\2\16\11\0\1\16\1\173\26\16\25\0\2\16\11\0"
         + "\14\16\1\174\13\16\25\0\2\16\11\0\20\16\1\175"
         + "\7\16\25\0\2\16\11\0\6\16\1\176\21\16\25\0"
         + "\2\16\11\0\6\16\1\177\21\16\25\0\2\16\11\0"
         + "\6\16\1\200\21\16\25\0\2\16\11\0\2\16\1\201"
         + "\6\16\1\202\16\16\25\0\2\16\11\0\5\16\1\203"
         + "\22\16\25\0\2\16\11\0\2\16\1\204\25\16\25\0"
         + "\2\16\11\0\1\16\1\205\26\16\25\0\2\16\11\0"
         + "\5\16\1\206\22\16\25\0\2\16\11\0\13\16\1\207"
         + "\14\16\25\0\2\16\11\0\6\16\1\210\21\16\25\0"
         + "\2\16\11\0\2\16\1\211\25\16\25\0\2\16\11\0"
         + "\4\16\1\212\23\16\25\0\2\16\11\0\1\213\27\16"
         + "\25\0\2\16\11\0\1\214\27\16\25\0\2\16\11\0"
         + "\22\16\1\215\5\16\25\0\2\16\11\0\3\16\1\216"
         + "\24\16\25\0\2\16\11\0\17\16\1\217\10\16\25\0"
         + "\2\16\11\0\15\16\1\220\12\16\25\0\2\16\11\0"
         + "\1\221\27\16\25\0\2\16\11\0\22\16\1\222\5\16"
         + "\25\0\2\16\11\0\13\16\1\223\14\16\25\0\2\16"
         + "\11\0\15\16\1\224\12\16\25\0\2\16\11\0\7\16"
         + "\1\225\20\16\25\0\2\16\11\0\5\16\1\226\22\16"
         + "\25\0\2\16\11\0\11\16\1\227\16\16\25\0\2\16"
         + "\11\0\5\16\1\230\22\16\25\0\2\16\11\0\14\16"
         + "\1\231\13\16\25\0\2\16\11\0\2\16\1\232\25\16"
         + "\25\0\2\16\11\0\14\16\1\233\13\16\25\0\2\16"
         + "\11\0\10\16\1\234\17\16\25\0\2\16\11\0\2\16"
         + "\1\235\25\16\25\0\2\16\11\0\6\16\1\236\21\16"
         + "\25\0\2\16\11\0\3\16\1\237\24\16\25\0\2\16"
         + "\11\0\10\16\1\240\17\16\25\0\2\16\11\0\17\16"
         + "\1\241\10\16\25\0\2\16\11\0\1\16\1\242\26\16"
         + "\25\0\2\16\11\0\2\16\1\243\25\16\25\0\2\16"
         + "\11\0\6\16\1\244\21\16\25\0\2\16\11\0\2\16"
         + "\1\245\25\16\25\0\2\16\11\0\13\16\1\246\14\16"
         + "\25\0\2\16\11\0\6\16\1\247\21\16\25\0\2\16"
         + "\11\0\13\16\1\250\14\16\25\0\2\16\11\0\2\16"
         + "\1\251\25\16\25\0\2\16\11\0\13\16\1\252\14\16"
         + "\25\0\2\16\11\0\13\16\1\253\14\16\25\0\2\16"
         + "\11\0\10\16\1\254\17\16\25\0\2\16\11\0\2\16"
         + "\1\255\25\16\25\0\2\16\11\0\15\16\1\256\12\16"
         + "\25\0\2\16\11\0\16\16\1\257\11\16\25\0\2\16"
         + "\11\0\12\16\1\260\15\16\25\0\2\16\11\0\6\16"
         + "\1\261\21\16\25\0\2\16\11\0\17\16\1\262\10\16"
         + "\25\0\2\16\11\0\14\16\1\263\13\16\25\0\2\16"
         + "\11\0\6\16\1\264\21\16\25\0\2\16\11\0\16\16"
         + "\1\265\11\16\25\0\2\16\11\0\6\16\1\266\21\16"
         + "\25\0\2\16\11\0\1\16\1\267\26\16\25\0\2\16"
         + "\11\0\2\16\1\270\25\16\25\0\2\16\11\0\17\16"
         + "\1\271\10\16\25\0\2\16\11\0\15\16\1\272\12\16"
         + "\25\0\2\16\11\0\5\16\1\273\22\16\25\0\2\16"
         + "\11\0\6\16\1\274\21\16\25\0\2\16\11\0\6\16"
         + "\1\275\21\16\25\0\2\16";

   private static int[] zzUnpackTrans()
   {
      int[] result = new int[7224];
      int offset = 0;
      offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
      return result;
   }

   private static int zzUnpackTrans(String packed, int offset, int[] result)
   {
      int i = 0; /* index in packed string  */
      int j = offset; /* index in unpacked array */
      int l = packed.length();
      while (i < l)
      {
         int count = packed.charAt(i++);
         int value = packed.charAt(i++);
         value--;
         do
         {
            result[j++] = value;
         }
         while (--count > 0);
      }
      return j;
   }

   /* error codes */
   private static final int ZZ_UNKNOWN_ERROR = 0;
   private static final int ZZ_NO_MATCH = 1;
   private static final int ZZ_PUSHBACK_2BIG = 2;

   /* error messages for the codes above */
   private static final String ZZ_ERROR_MSG[] = {
      "Unkown internal scanner error", "Error: could not match input", "Error: pushback value was too large"
   };

   /**
    * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
    */
   private static final int[] ZZ_ATTRIBUTE = zzUnpackAttribute();

   private static final String ZZ_ATTRIBUTE_PACKED_0 = "\3\0\2\11\3\1\1\11\21\1\1\11\1\1\3\11"
         + "\2\1\15\11\6\1\1\11\1\1\2\11\1\0\31\1"
         + "\3\11\150\1";

   private static int[] zzUnpackAttribute()
   {
      int[] result = new int[189];
      int offset = 0;
      offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
      return result;
   }

   private static int zzUnpackAttribute(String packed, int offset, int[] result)
   {
      int i = 0; /* index in packed string  */
      int j = offset; /* index in unpacked array */
      int l = packed.length();
      while (i < l)
      {
         int count = packed.charAt(i++);
         int value = packed.charAt(i++);
         do
         {
            result[j++] = value;
         }
         while (--count > 0);
      }
      return j;
   }

   /**
    * the input device
    */
   private java.io.Reader zzReader;

   /**
    * the current state of the DFA
    */
   private int zzState;

   /**
    * the current lexical state
    */
   private int zzLexicalState = YYINITIAL;

   /**
    * this buffer contains the current text to be matched and is
    * the source of the yytext() string
    */
   private char zzBuffer[] = new char[ZZ_BUFFERSIZE];

   /**
    * the textposition at the last accepting state
    */
   private int zzMarkedPos;

   /**
    * the textposition at the last state to be included in yytext
    */
   private int zzPushbackPos;

   /**
    * the current text position in the buffer
    */
   private int zzCurrentPos;

   /**
    * startRead marks the beginning of the yytext() string in the buffer
    */
   private int zzStartRead;

   /**
    * endRead marks the last character in the buffer, that has been read
    * from input
    */
   private int zzEndRead;

   /**
    * number of newlines encountered up to the start of the matched text
    */
   private int yyline;

   /**
    * the number of characters up to the start of the matched text
    */
   private int yychar;

   /**
    * the number of characters from the last newline up to the start of the
    * matched text
    */
   private int yycolumn;

   /**
    * zzAtBOL == true <=> the scanner is currently at the beginning of a line
    */
   private boolean zzAtBOL = true;

   /**
    * zzAtEOF == true <=> the scanner is at the EOF
    */
   private boolean zzAtEOF;

   /* user code: */

   private static TokenType[] tokenTypes = {
      new TokenType(Token.TYPE_STRING, "comment", TokenType.KIND_OTHER),
      new TokenType(Token.TYPE_IDENT, "identifier", TokenType.KIND_OTHER),
      new TokenType(Token.TYPE_NUMBER, "number", TokenType.KIND_OTHER),
      new TokenType(3, "auto", TokenType.KIND_KEYWORD),
      new TokenType(7, "break", TokenType.KIND_KEYWORD),
      new TokenType(8, "case", TokenType.KIND_KEYWORD),
      new TokenType(10, "char", TokenType.KIND_KEYWORD),
      new TokenType(13, "const", TokenType.KIND_KEYWORD),
      new TokenType(15, "continue", TokenType.KIND_KEYWORD),
      new TokenType(16, "default", TokenType.KIND_KEYWORD),
      new TokenType(18, "do", TokenType.KIND_KEYWORD),
      new TokenType(19, "double", TokenType.KIND_KEYWORD),
      new TokenType(21, "else", TokenType.KIND_KEYWORD),
      new TokenType(22, "enum", TokenType.KIND_KEYWORD),
      new TokenType(25, "extern", TokenType.KIND_KEYWORD),
      new TokenType(27, "float", TokenType.KIND_KEYWORD),
      new TokenType(28, "for", TokenType.KIND_KEYWORD),
      new TokenType(30, "goto", TokenType.KIND_KEYWORD),
      new TokenType(31, "if", TokenType.KIND_KEYWORD),
      new TokenType(33, "int", TokenType.KIND_KEYWORD),
      new TokenType(34, "long", TokenType.KIND_KEYWORD),
      new TokenType(46, "register", TokenType.KIND_KEYWORD),
      new TokenType(48, "return", TokenType.KIND_KEYWORD),
      new TokenType(49, "short", TokenType.KIND_KEYWORD),
      new TokenType(50, "signed", TokenType.KIND_KEYWORD),
      new TokenType(51, "sizeof", TokenType.KIND_KEYWORD),
      new TokenType(52, "static", TokenType.KIND_KEYWORD),
      new TokenType(54, "struct", TokenType.KIND_KEYWORD),
      new TokenType(55, "switch", TokenType.KIND_KEYWORD),
      new TokenType(61, "typedef", TokenType.KIND_KEYWORD),
      new TokenType(64, "union", TokenType.KIND_KEYWORD),
      new TokenType(65, "unsigned", TokenType.KIND_KEYWORD),
      new TokenType(69, "volatile", TokenType.KIND_KEYWORD),
      new TokenType(71, "while", TokenType.KIND_KEYWORD),
      new TokenType(100, ";", TokenType.KIND_OTHER),
      new TokenType(101, "==", TokenType.KIND_OPERATOR),
      new TokenType(102, "+", TokenType.KIND_OPERATOR),
      new TokenType(103, "-", TokenType.KIND_OPERATOR),
      new TokenType(104, "/", TokenType.KIND_OPERATOR),
      new TokenType(105, "*", TokenType.KIND_OPERATOR),
      new TokenType(106, ",", TokenType.KIND_OPERATOR),
      new TokenType(107, ">=", TokenType.KIND_OPERATOR),
      new TokenType(108, "<=", TokenType.KIND_OPERATOR),
      new TokenType(109, "=", TokenType.KIND_OPERATOR),
      new TokenType(110, "!", TokenType.KIND_OPERATOR),
      new TokenType(111, "\"", TokenType.KIND_OTHER),
      new TokenType(112, "&", TokenType.KIND_OPERATOR),
      new TokenType(113, "{", TokenType.KIND_OTHER),
      new TokenType(114, "}", TokenType.KIND_OTHER),
      new TokenType(115, "(", TokenType.KIND_OTHER),
      new TokenType(116, ")", TokenType.KIND_OTHER),
      new TokenType(117, "[", TokenType.KIND_OTHER),
      new TokenType(118, "]", TokenType.KIND_OTHER),
      new TokenType(119, "|", TokenType.KIND_OPERATOR),
      new TokenType(120, "\\", TokenType.KIND_OTHER),
      new TokenType(121, ".", TokenType.KIND_OPERATOR),
      new TokenType(122, ">", TokenType.KIND_OPERATOR),
      new TokenType(123, "<", TokenType.KIND_OPERATOR),
      new TokenType(124, ":", TokenType.KIND_OTHER),
      new TokenType(125, "?", TokenType.KIND_OTHER)
   };

   private int comment_count;

   /**
    * Defaultconstructor : erzeugt einen neuen CScanner
    */
   public CScanner()
   {
      comment_count = 0;
   }

   public TokenType[] getTokenTypes()
   {
      return tokenTypes;
   }

   /**
    * Creates a new scanner
    * There is also a java.io.InputStream version of this constructor.
    *
    * @param in the java.io.Reader to read input from.
    */
   public CScanner(java.io.Reader in)
   {
      this.zzReader = in;
   }

   /**
    * Creates a new scanner.
    * There is also java.io.Reader version of this constructor.
    *
    * @param in the java.io.Inputstream to read input from.
    */
   public CScanner(java.io.InputStream in)
   {
      this(new java.io.InputStreamReader(in));
   }

   /**
    * Unpacks the compressed character translation table.
    *
    * @param packed the packed character translation table
    *
    * @return the unpacked character translation table
    */
   private static char[] zzUnpackCMap(String packed)
   {
      char[] map = new char[0x10000];
      int i = 0; /* index in packed string  */
      int j = 0; /* index in unpacked array */
      while (i < 144)
      {
         int count = packed.charAt(i++);
         char value = packed.charAt(i++);
         do
         {
            map[j++] = value;
         }
         while (--count > 0);
      }
      return map;
   }

   /**
    * Refills the input buffer.
    *
    * @return <code>false</code>, iff there was new input.
    *
    * @throws java.io.IOException if any I/O-Error occurs
    */
   private boolean zzRefill() throws java.io.IOException
   {

      /* first: make room (if you can) */
      if (zzStartRead > 0)
      {
         System.arraycopy(zzBuffer, zzStartRead, zzBuffer, 0, zzEndRead - zzStartRead);

         /* translate stored positions */
         zzEndRead -= zzStartRead;
         zzCurrentPos -= zzStartRead;
         zzMarkedPos -= zzStartRead;
         zzPushbackPos -= zzStartRead;
         zzStartRead = 0;
      }

      /* is the buffer big enough? */
      if (zzCurrentPos >= zzBuffer.length)
      {
         /* if not: blow it up */
         char newBuffer[] = new char[zzCurrentPos * 2];
         System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
         zzBuffer = newBuffer;
      }

      /* finally: fill the buffer with new input */
      int numRead = zzReader.read(zzBuffer, zzEndRead, zzBuffer.length - zzEndRead);

      if (numRead < 0)
      {
         return true;
      }
      else
      {
         zzEndRead += numRead;
         return false;
      }
   }

   /**
    * Closes the input stream.
    */
   public final void yyclose() throws java.io.IOException
   {
      zzAtEOF = true; /* indicate end of file */
      zzEndRead = zzStartRead; /* invalidate buffer    */

      if (zzReader != null)
      {
         zzReader.close();
      }
   }

   /**
    * Resets the scanner to read from a new input stream.
    * Does not close the old reader.
    * <p/>
    * All internal variables are reset, the old input stream
    * <b>cannot</b> be reused (internal buffer is discarded and lost).
    * Lexical state is set to <tt>ZZ_INITIAL</tt>.
    *
    * @param reader the new input stream
    */
   public final void yyreset(java.io.Reader reader)
   {
      zzReader = reader;
      zzAtBOL = true;
      zzAtEOF = false;
      zzEndRead = zzStartRead = 0;
      zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
      yyline = yychar = yycolumn = 0;
      zzLexicalState = YYINITIAL;
   }

   /**
    * Returns the current lexical state.
    */
   public final int yystate()
   {
      return zzLexicalState;
   }

   /**
    * Enters a new lexical state
    *
    * @param newState the new lexical state
    */
   public final void yybegin(int newState)
   {
      zzLexicalState = newState;
   }

   /**
    * Returns the text matched by the current regular expression.
    */
   public final String yytext()
   {
      return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);
   }

   /**
    * Returns the character at position <tt>pos</tt> from the
    * matched text.
    * <p/>
    * It is equivalent to yytext().charAt(pos), but faster
    *
    * @param pos the position of the character to fetch.
    *            A value from 0 to yylength()-1.
    *
    * @return the character at position pos
    */
   public final char yycharat(int pos)
   {
      return zzBuffer[zzStartRead + pos];
   }

   /**
    * Returns the length of the matched text region.
    */
   public final int yylength()
   {
      return zzMarkedPos - zzStartRead;
   }

   /**
    * Reports an error that occured while scanning.
    * <p/>
    * In a wellformed scanner (no or only correct usage of
    * yypushback(int) and a match-all fallback rule) this method
    * will only be called with things that "Can't Possibly Happen".
    * If this method is called, something is seriously wrong
    * (e.g. a JFlex bug producing a faulty scanner etc.).
    * <p/>
    * Usual syntax/scanner level error handling should be done
    * in error fallback rules.
    *
    * @param errorCode the code of the errormessage to display
    */
   private void zzScanError(int errorCode)
   {
      String message;
      try
      {
         message = ZZ_ERROR_MSG[errorCode];
      }
      catch (ArrayIndexOutOfBoundsException e)
      {
         message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
      }

      throw new Error(message);
   }

   /**
    * Pushes the specified amount of characters back into the input stream.
    * <p/>
    * They will be read again by then next call of the scanning method
    *
    * @param number the number of characters to be read again.
    *               This number must not be greater than yylength()!
    */
   public void yypushback(int number)
   {
      if (number > yylength())
      {
         zzScanError(ZZ_PUSHBACK_2BIG);
      }

      zzMarkedPos -= number;
   }

   /**
    * Resumes scanning until the next regular expression is matched,
    * the end of input is encountered or an I/O-Error occurs.
    *
    * @return the next token
    *
    * @throws java.io.IOException if any I/O-Error occurs
    */
   public Token yylex() throws java.io.IOException
   {
      int zzInput;
      int zzAction;

      // cached fields:
      int zzCurrentPosL;
      int zzMarkedPosL;
      int zzEndReadL = zzEndRead;
      char[] zzBufferL = zzBuffer;
      char[] zzCMapL = ZZ_CMAP;

      int[] zzTransL = ZZ_TRANS;
      int[] zzRowMapL = ZZ_ROWMAP;
      int[] zzAttrL = ZZ_ATTRIBUTE;

      while (true)
      {
         zzMarkedPosL = zzMarkedPos;

         boolean zzR = false;
         for (zzCurrentPosL = zzStartRead; zzCurrentPosL < zzMarkedPosL; zzCurrentPosL++)
         {
            switch (zzBufferL[zzCurrentPosL])
            {
               case '\u000B':
               case '\u000C':
               case '\u0085':
               case '\u2028':
               case '\u2029':
                  yyline++;
                  zzR = false;
                  break;
               case '\r':
                  yyline++;
                  zzR = true;
                  break;
               case '\n':
                  if (zzR)
                  {
                     zzR = false;
                  }
                  else
                  {
                     yyline++;
                  }
                  break;
               default :
                  zzR = false;
            }
         }

         if (zzR)
         {
            // peek one character ahead if it is \n (if we have counted one line too much)
            boolean zzPeek;
            if (zzMarkedPosL < zzEndReadL)
            {
               zzPeek = zzBufferL[zzMarkedPosL] == '\n';
            }
            else if (zzAtEOF)
            {
               zzPeek = false;
            }
            else
            {
               boolean eof = zzRefill();
               zzMarkedPosL = zzMarkedPos;
               zzBufferL = zzBuffer;
               if (eof)
               {
                  zzPeek = false;
               }
               else
               {
                  zzPeek = zzBufferL[zzMarkedPosL] == '\n';
               }
            }
            if (zzPeek)
            {
               yyline--;
            }
         }
         zzAction = -1;

         zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;

         zzState = zzLexicalState;

         zzForAction : {
            while (true)
            {

               if (zzCurrentPosL < zzEndReadL)
               {
                  zzInput = zzBufferL[zzCurrentPosL++];
               }
               else if (zzAtEOF)
               {
                  zzInput = YYEOF;
                  break zzForAction;
               }
               else
               {
                  // store back cached positions
                  zzCurrentPos = zzCurrentPosL;
                  zzMarkedPos = zzMarkedPosL;
                  boolean eof = zzRefill();
                  // get translated positions and possibly new buffer
                  zzCurrentPosL = zzCurrentPos;
                  zzMarkedPosL = zzMarkedPos;
                  zzBufferL = zzBuffer;
                  zzEndReadL = zzEndRead;
                  if (eof)
                  {
                     zzInput = YYEOF;
                     break zzForAction;
                  }
                  else
                  {
                     zzInput = zzBufferL[zzCurrentPosL++];
                  }
               }
               int zzNext = zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];
               if (zzNext == -1)
               {
                  break zzForAction;
               }
               zzState = zzNext;

               int zzAttributes = zzAttrL[zzState];
               if ((zzAttributes & 1) == 1)
               {
                  zzAction = zzState;
                  zzMarkedPosL = zzCurrentPosL;
                  if ((zzAttributes & 8) == 8)
                  {
                     break zzForAction;
                  }
               }

            }
         }

         // store back cached position
         zzMarkedPos = zzMarkedPosL;

         switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction])
         {
            case 62:
               {
                  return (new KeyWordToken(yytext(), 19, yyline));
               }
            case 69:
               break;
            case 50:
               {
                  return (new KeyWordToken(yytext(), 7, yyline));
               }
            case 70:
               break;
            case 57:
               {
                  return (new KeyWordToken(yytext(), 52, yyline));
               }
            case 71:
               break;
            case 18:
               {
                  return (new Token(yytext(), 114, yyline));
               }
            case 72:
               break;
            case 9:
               {
                  return (new Token(yytext(), 109, yyline));
               }
            case 73:
               break;
            case 52:
               {
                  return (new KeyWordToken(yytext(), 49, yyline));
               }
            case 74:
               break;
            case 32:
               {
                  return (new KeyWordToken(yytext(), 31, yyline));
               }
            case 75:
               break;
            case 58:
               {
                  return (new KeyWordToken(yytext(), 54, yyline));
               }
            case 76:
               break;
            case 25:
               {
                  return (new Token(yytext(), 121, yyline));
               }
            case 77:
               break;
            case 45:
               {
                  return (new KeyWordToken(yytext(), 10, yyline));
               }
            case 78:
               break;
            case 40:
               {
                  return (new KeyWordToken(yytext(), 28, yyline));
               }
            case 79:
               break;
            case 20:
               {
                  return (new Token(yytext(), 116, yyline));
               }
            case 80:
               break;
            case 39:
               {
                  return (new KeyWordToken(yytext(), 33, yyline));
               }
            case 81:
               break;
            case 63:
               {
                  return (new KeyWordToken(yytext(), 61, yyline));
               }
            case 82:
               break;
            case 8:
               {
                  return (new Token(yytext(), 100, yyline));
               }
            case 83:
               break;
            case 2:
               {
                  return (new EOLToken(yyline));
               }
            case 84:
               break;
            case 14:
               {
                  return (new Token(yytext(), 123, yyline));
               }
            case 85:
               break;
            case 22:
               {
                  return (new Token(yytext(), 118, yyline));
               }
            case 86:
               break;
            case 10:
               {
                  return (new Token(yytext(), 102, yyline));
               }
            case 87:
               break;
            case 27:
               {
                  return (new Token(yytext(), 125, yyline));
               }
            case 88:
               break;
            case 1:
               {
                  return (new Token(yytext(), Token.TYPE_STRING, yyline));
               }
            case 89:
               break;
            case 31:
               {
                  yybegin(COMMENT);
                  comment_count = comment_count + 1;
                  return (new Token(yytext(), Token.TYPE_STRING, yyline));
               }
            case 90:
               break;
            case 65:
               {
                  return (new KeyWordToken(yytext(), 65, yyline));
               }
            case 91:
               break;
            case 64:
               {
                  return (new KeyWordToken(yytext(), 16, yyline));
               }
            case 92:
               break;
            case 4:
               {
                  return (new Token(yytext(), 104, yyline));
               }
            case 93:
               break;
            case 43:
               {
                  return (new KeyWordToken(yytext(), 21, yyline));
               }
            case 94:
               break;
            case 37:
               {
                  comment_count = comment_count + 1;
                  return (new Token(yytext(), Token.TYPE_STRING, yyline));
               }
            case 95:
               break;
            case 6:
               {
                  return (new Token(yytext(), 111, yyline));
               }
            case 96:
               break;
            case 12:
               {
                  return (new Token(yytext(), 106, yyline));
               }
            case 97:
               break;
            case 33:
               {
                  return (new KeyWordToken(yytext(), 18, yyline));
               }
            case 98:
               break;
            case 38:
               {
                  comment_count = comment_count - 1;
                  if (comment_count == 0)
                  {
                     yybegin(YYINITIAL);
                  }
                  return (new Token(yytext(), Token.TYPE_STRING, yyline));
               }
            case 99:
               break;
            case 66:
               {
                  return (new KeyWordToken(yytext(), 46, yyline));
               }
            case 100:
               break;
            case 68:
               {
                  return (new KeyWordToken(yytext(), 69, yyline));
               }
            case 101:
               break;
            case 60:
               {
                  return (new KeyWordToken(yytext(), 51, yyline));
               }
            case 102:
               break;
            case 17:
               {
                  return (new Token(yytext(), 113, yyline));
               }
            case 103:
               break;
            case 36:
               {
                  return (new Token(yytext(), 108, yyline));
               }
            case 104:
               break;
            case 3:
               { /*do nothing*/
               }
            case 105:
               break;
            case 56:
               {
                  return (new KeyWordToken(yytext(), 25, yyline));
               }
            case 106:
               break;
            case 44:
               {
                  return (new KeyWordToken(yytext(), 8, yyline));
               }
            case 107:
               break;
            case 55:
               {
                  return (new KeyWordToken(yytext(), 48, yyline));
               }
            case 108:
               break;
            case 47:
               {
                  return (new KeyWordToken(yytext(), 30, yyline));
               }
            case 109:
               break;
            case 24:
               {
                  return (new Token(yytext(), 120, yyline));
               }
            case 110:
               break;
            case 53:
               {
                  return (new KeyWordToken(yytext(), 27, yyline));
               }
            case 111:
               break;
            case 19:
               {
                  return (new Token(yytext(), 115, yyline));
               }
            case 112:
               break;
            case 7:
               {
                  return (new Token(yytext(), Token.TYPE_IDENT, yyline));
               }
            case 113:
               break;
            case 30:
               {
                  yybegin(LINE_COMMENT);
                  return (new Token(yytext(), Token.TYPE_STRING, yyline));
               }
            case 114:
               break;
            case 61:
               {
                  return (new KeyWordToken(yytext(), 55, yyline));
               }
            case 115:
               break;
            case 13:
               {
                  return (new Token(yytext(), 122, yyline));
               }
            case 116:
               break;
            case 21:
               {
                  return (new Token(yytext(), 117, yyline));
               }
            case 117:
               break;
            case 46:
               {
                  return (new KeyWordToken(yytext(), 34, yyline));
               }
            case 118:
               break;
            case 34:
               {
                  return (new Token(yytext(), 101, yyline));
               }
            case 119:
               break;
            case 26:
               {
                  return (new Token(yytext(), 124, yyline));
               }
            case 120:
               break;
            case 51:
               {
                  return (new KeyWordToken(yytext(), 13, yyline));
               }
            case 121:
               break;
            case 23:
               {
                  return (new Token(yytext(), 119, yyline));
               }
            case 122:
               break;
            case 28:
               {
                  return (new Token(yytext(), Token.TYPE_NUMBER, yyline));
               }
            case 123:
               break;
            case 49:
               {
                  return (new KeyWordToken(yytext(), 64, yyline));
               }
            case 124:
               break;
            case 67:
               {
                  return (new KeyWordToken(yytext(), 15, yyline));
               }
            case 125:
               break;
            case 11:
               {
                  return (new Token(yytext(), 103, yyline));
               }
            case 126:
               break;
            case 41:
               {
                  return (new KeyWordToken(yytext(), 3, yyline));
               }
            case 127:
               break;
            case 54:
               {
                  return (new KeyWordToken(yytext(), 71, yyline));
               }
            case 128:
               break;
            case 15:
               {
                  return (new Token(yytext(), 110, yyline));
               }
            case 129:
               break;
            case 5:
               {
                  return (new Token(yytext(), 105, yyline));
               }
            case 130:
               break;
            case 42:
               {
                  return (new KeyWordToken(yytext(), 22, yyline));
               }
            case 131:
               break;
            case 59:
               {
                  return (new KeyWordToken(yytext(), 50, yyline));
               }
            case 132:
               break;
            case 48:
               {
                  return (new KeyWordToken(yytext(), 68, yyline));
               }
            case 133:
               break;
            case 16:
               {
                  return (new Token(yytext(), 112, yyline));
               }
            case 134:
               break;
            case 35:
               {
                  return (new Token(yytext(), 107, yyline));
               }
            case 135:
               break;
            case 29:
               {
                  yybegin(YYINITIAL);
                  return (new EOLToken(yyline));
               }
            case 136:
               break;
            default :
               if (zzInput == YYEOF && zzStartRead == zzCurrentPos)
               {
                  zzAtEOF = true;
                  return null;
               }
               else
               {
                  zzScanError(ZZ_NO_MATCH);
               }
         }
      }
   }
}
